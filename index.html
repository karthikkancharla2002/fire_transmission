<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Fire Transmission</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    #map { height: 100%; width: 100%; }
  </style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
<script src="https://unpkg.com/geotiff"></script>
<script src="osmtogeojson.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
<script src="https://unpkg.com/delaunator@5.0.0/delaunator.min.js"></script>


<script>
  const map = L.map('map').setView([34.0224, -118.2851], 15);

  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);

  const drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

  const drawControl = new L.Control.Draw({
    draw: { polygon: true, rectangle: false, polyline: false, circle: false, marker: false, circlemarker: false },
    edit: { featureGroup: drawnItems }
  });
  map.addControl(drawControl);

  let currentBuildingsLayer;
  let demRaster = null;
  let elevationData = null;

  fetch('/topology_data/USGS_1_n34w119.tif')
    .then(res => res.arrayBuffer())
    .then(buffer => GeoTIFF.fromArrayBuffer(buffer))
    .then(tiff => tiff.getImage())
    .then(image => {
      demRaster = image;
      console.log("DEM loaded.");
      const [xmin, ymin, xmax, ymax] = demRaster.getBoundingBox();
      const bounds = [[ymin, xmin], [ymax, xmax]];
      L.rectangle(bounds, {
        color: "#00bfff", weight: 2, fillOpacity: 0.1, dashArray: "5,5"
      }).addTo(map).bindPopup("DEM coverage area");
      map.fitBounds(bounds);
      return demRaster.readRasters();
    })
    .then(data => {
      elevationData = data[0];
      console.log("DEM elevation cached.");
    });

  function getElevationAtLatLng(lat, lng) {
    if (!demRaster || !elevationData) return null;
    const [xmin, ymin, xmax, ymax] = demRaster.getBoundingBox();
    const width = demRaster.getWidth();
    const height = demRaster.getHeight();
    const x = Math.floor((lng - xmin) / (xmax - xmin) * width);
    const y = Math.floor((ymax - lat) / (ymax - ymin) * height);
    if (x < 0 || x >= width || y < 0 || y >= height) return null;
    return elevationData[y * width + x];
  }

  // Define UTM Zone 11N (for Los Angeles)
  proj4.defs("EPSG:32611", "+proj=utm +zone=11 +datum=WGS84 +units=m +no_defs");


  async function compute3DSurfaceArea(polygon) {
  const spacing = 0.0003; // About 30m spacing
  const grid = turf.pointGrid(turf.bbox(polygon), spacing, { mask: polygon });

  const points3D = [];

  for (const pt of grid.features) {
    const [lon, lat] = pt.geometry.coordinates;
    const z = getElevationAtLatLng(lat, lon);
    if (z !== null && !isNaN(z)) {
      const [x, y] = proj4("EPSG:4326", "EPSG:32611", [lon, lat]);
      points3D.push([x, y, z]);
    }
  }

  // Create 2D points for triangulation
  const delaunay = Delaunator.from(points3D.map(p => [p[0], p[1]]));

  let area = 0;
  for (let i = 0; i < delaunay.triangles.length; i += 3) {
    const a = points3D[delaunay.triangles[i]];
    const b = points3D[delaunay.triangles[i + 1]];
    const c = points3D[delaunay.triangles[i + 2]];
    area += calculateTriangleArea(a, b, c);
  }

  return area / 1e6; // in km²
}


function calculateTriangleArea(a, b, c) {
  const ab = [b[0] - a[0], b[1] - a[1], b[2] - a[2]];
  const ac = [c[0] - a[0], c[1] - a[1], c[2] - a[2]];
  const cross = [
    ab[1] * ac[2] - ab[2] * ac[1],
    ab[2] * ac[0] - ab[0] * ac[2],
    ab[0] * ac[1] - ab[1] * ac[0]
  ];
  return 0.5 * Math.sqrt(cross[0]**2 + cross[1]**2 + cross[2]**2);
}

  function computeFlatArea(polygon) {
    const areaSqMeters = turf.area(polygon); 
    return areaSqMeters; // Return in m² (no division here)
  }




  fetch('transmission_lines.geojson')
    .then(res => res.json())
    .then(data => {
      L.geoJSON(data, {
        style: { color: 'blue', weight: 3 }
      }).addTo(map);
    });

  map.on(L.Draw.Event.CREATED, function (e) {
    drawnItems.clearLayers();
    if (currentBuildingsLayer) map.removeLayer(currentBuildingsLayer);

    const drawnLayer = e.layer;
    drawnItems.addLayer(drawnLayer);
    const polygon = drawnLayer.toGeoJSON();
    const [minLon, minLat, maxLon, maxLat] = turf.bbox(polygon);

    const query = `
      [out:json][timeout:25];
      (
        way["building"](${minLat},${minLon},${maxLat},${maxLon});
      );
      out body;
      >;
      out skel qt;
    `;
    const overpassUrl = "https://overpass-api.de/api/interpreter?data=" + encodeURIComponent(query);

    fetch(overpassUrl)
      .then(res => res.json())
      .then(osmData => {
        const geojson = osmtogeojson(osmData);
        const filteredFeatures = geojson.features.filter(f => turf.booleanIntersects(f, polygon));
        currentBuildingsLayer = L.geoJSON({
          type: "FeatureCollection",
          features: filteredFeatures
        }, {
          style: { color: '#ff0000', weight: 2, fillOpacity: 0.6 }
        }).addTo(map);

        const houseCount = filteredFeatures.length;
        const flatArea = computeFlatArea(polygon);

        compute3DSurfaceArea(polygon).then(surfaceAreaKm2 => {
          const flatAreaM2 = computeFlatArea(polygon);
          
          // Convert to human-readable formats
          const surfaceAreaM2 = surfaceAreaKm2 * 1e6; // Reverse previous km² division
          const flatAreaKm2 = flatAreaM2 / 1e6;

          // Format numbers
          const terrainLabel = `${surfaceAreaKm2.toFixed(3)} km² (${surfaceAreaM2.toLocaleString()} m²)`;
          const flatLabel = `${flatAreaKm2.toFixed(3)} km² (${flatAreaM2.toLocaleString()} m²)`;


          alert(`🏠 Total buildings: ${houseCount}\n` +
                `⛰️ Terrain-aware area: ${terrainLabel}\n` +
                `🟦 Flat 2D area: ${flatLabel}`);

        });
      })
      .catch(err => {
        console.error("Overpass error:", err);
        alert("Could not fetch building data.");
      });
  });
</script>
</body>
</html>